// Generated by LiveScript 1.3.1
var notes, track, viewWidth, hintOffset, offset, lv, counter, score, drawGauge, remove, replenish, render, start, startTime, engine, handler;
notes = [];
track = document.querySelector('.track');
viewWidth = 800;
hintOffset = 100;
offset = 1000;
lv = 0;
counter = {
  avgDiff: 0,
  diff: 0,
  good: 0,
  ok: 0,
  bad: 0,
  combo: 0,
  maxCombo: 0,
  total: 0,
  gauge: 0
};
score = {
  density: document.querySelector('.score .density'),
  diff: document.querySelector('.score .diff'),
  combo: document.querySelector('.score .combo'),
  maxCombo: document.querySelector('.score .max-combo'),
  good: document.querySelector('.indicator .good'),
  ok: document.querySelector('.indicator .ok'),
  lv: document.querySelector('.lv span'),
  gauge: document.querySelector('.gauge .bar')
};
drawGauge = function(){
  return score.gauge.style.width = counter.gauge * 100 / 50 + "%";
};
remove = function(note, hit){
  var e;
  hit == null && (hit = false);
  if (!note.hit) {
    note.hit = hit;
  }
  note.style.display = 'none';
  try {
    if (!note.deleted) {
      track.removeChild(note);
    }
  } catch (e$) {
    e = e$;
    console.log("try to remove a note that is not child of track");
  }
  note.deleted = true;
  counter.total += 1;
  if (note.hit && counter.combo > 10) {
    counter.gauge += 2 / Math.sqrt(lv);
    drawGauge();
  }
  if (note && !note.hit) {
    counter.combo = 0;
    counter.bad += 1;
    counter.gauge -= 2;
    if (counter.gauge < 0) {
      counter.gauge = 0;
    }
    return drawGauge();
  }
};
replenish = function(count, speed, sep){
  var i$, i, node, results$ = [];
  count == null && (count = 100);
  speed == null && (speed = 320);
  sep == null && (sep = 200);
  for (i$ = 0; i$ < count; ++i$) {
    i = i$;
    node = document.createElement("div");
    track.appendChild(node);
    node.type = Math.random() > 0.5 ? 1 : 2;
    node.classList.add('note', node.type === 1 ? 'don' : 'ka');
    node.speed = speed;
    node.time = offset;
    notes.push(node);
    results$.push(offset = offset + sep);
  }
  return results$;
};
render = function(elapsed){
  var i$, ref$, len$, note, position, sep, len, speed;
  for (i$ = 0, len$ = (ref$ = notes).length; i$ < len$; ++i$) {
    note = ref$[i$];
    if (note.deleted) {
      continue;
    }
    note.position = position = note.speed * (note.time - elapsed) * 0.001 + hintOffset;
    note.style.left = position + "px";
    if (position < -100) {
      remove(note);
    }
  }
  notes = notes.filter(function(it){
    return !it.deleted;
  });
  sep = 20 + 180 * Math.exp(-0.05 * lv);
  len = Math.round(3 * 1000 / sep);
  if (notes.length < len) {
    if (counter.gauge >= 50) {
      lv = lv + 1;
      counter.gauge = 0;
      drawGauge();
      score.lv.innerHTML = lv;
    }
    sep = 20 + 160 * Math.exp(-0.04 * lv);
    speed = (100 * 900 / sep) * Math.pow(0.99, lv);
    replenish(len, speed, sep);
    return score.density.innerHTML = (1000 / sep + "").substring(0, 6);
  }
};
start = 0;
startTime = 0;
engine = function(elapsed){
  if (!start) {
    startTime = new Date().getTime();
    start = elapsed;
  }
  render(elapsed - start - 1000);
  return requestAnimationFrame(engine);
};
requestAnimationFrame(engine);
handler = null;
document.body.addEventListener('keypress', function(e){
  var _, time, elapsed, key, type, ref$, idx, mindiff, i$, i, note, diff;
  _ = function(node, delay){
    delay == null && (delay = 100);
    if (node) {
      node.style.display = 'block';
    }
    clearTimeout(handler);
    return handler = setTimeout(function(){
      score.good.style.display = 'none';
      score.ok.style.display = 'none';
      return handler = null;
    }, delay);
  };
  time = new Date().getTime();
  elapsed = time - startTime - 1000;
  key = e.keyCode;
  type = 0;
  if (key === 100 || key === 106 || key === 68 || key === 74) {
    type = 1;
  }
  if (key === 101 || key === 105 || key === 69 || key === 73) {
    type = 2;
  }
  if (!type) {
    return;
  }
  ref$ = [0, 'NA'], idx = ref$[0], mindiff = ref$[1];
  for (i$ = 0; i$ < 5; ++i$) {
    i = i$;
    note = notes[i];
    if (!note) {
      break;
    }
    diff = Math.abs(note.time - elapsed);
    if (note.position - 100 < 100 && mindiff === 'NA' || diff < mindiff) {
      idx = i;
      mindiff = diff;
    }
  }
  note = notes[idx];
  if (mindiff !== 'NA' && mindiff < 400 && note) {
    if (type !== note.type || mindiff >= 200) {
      _(null, 0);
      remove(note);
    } else if (mindiff < 80) {
      counter.good += 1;
      counter.combo += 1;
      _(score.good, 100);
      remove(note, true);
    } else if (mindiff < 200) {
      counter.ok += 1;
      counter.combo += 1;
      _(score.ok, 100);
      remove(note, true);
    } else {
      remove(note);
    }
    if (counter.combo > counter.maxCombo) {
      counter.maxCombo = counter.combo;
    }
    counter.diff += mindiff;
    counter.avgDiff = counter.diff / (counter.good + counter.ok + counter.bad);
    score.diff.innerHTML = (Math.round(100 * counter.avgDiff) * 0.01 + "").substring(0, 5) + "ms";
    score.combo.innerHTML = counter.combo;
    return score.maxCombo.innerHTML = counter.maxCombo;
  }
});